
# Архитектура компиляторов
- [Чем отличаются компилятор и интерпретатор?](#чем-отличаются-компилятор-и-интерпретатор)
- [Преимущества компилятора перед интерпретатором?](#преимущества-компилятора-перед-интерпретатором)
- [Чем отличаются компилятор в машинный код и в байткод виртуальной машины?](#чем-отличаются-компилятор-в-машинный-код-и-в-байткод-виртуальной-машины)

<br/>

## Чем отличаются компилятор и интерпретатор?

#### **Компилятор** генерирует исполняемый файл **ДО** запуска. Информация об ошибках появится ещё **на этапе сборки**  
#### **Интерпретатор** **ВЫПОЛНЯЕТ** исходный код. Информация об ошибках появляется постепенно **во время выполнения**

<br/>

|Характеристика|Компилятор|Интерпретатор|
|:-|:-|:-|
|Преобразование кода|перевод в машинный/байт код до выполнения|последовательное выполнение|
|Выходной файл|создаёт (не всегда)|нету|
|Скорость выполнения|высокая|низкая|


<br/>

## Преимущества компилятора перед интерпретатором

### 1. _производительность_
- оптимизация на этапе компиляции: агрессивные оптимизации, удаление мертвого кода
- отсутствие накладных расходов на анализ кода во время выполнения

### 2. _безопасность_
- раннее обнаружение ошибок: синтаксические и семантические ошибки выявляются ещё до запуска
- защита исходного кода: распространяется скомпилированная версия, которую декомпилировать непросто

### 3. _независимость от окружения_
- скомпилированная программа может работать без установленного языка программирования
- минимальные зависимости от среды выполнения

### 4. _предсказуемость_
- статический анализ позволяет точно определить поведение программы
- детерминированное время выполнения критических участков

<br/>

## Чем отличаются компилятор в машинный код и в байткод виртуальной машины?
Ответ - кроссплатформенность у второго

### Машинный код:
```
Исходный код -> [компиляция] -> машинный код
```

**_преимущества:_**
- максимальная производительность - прямой доступ к ресурсам процессора
- отсутствие виртуальной машины - минимальные накладные расходы
- прямая работа с железом - низкоуровневый доступ

**_недостотатки:_**
- платформенная зависимость - под каждую архитектуру нужна отдельная компиляция
- отсутствие переносимости - код для x86 не работает на ARM

**_примеры:_**
C, C++, Rust, Fortran

### Байткод виртуальной машины:
```
Исходный код -> [компиляция] -> байткод -> [виртуальная машина] -> машинный код
```

**_преимущества:_**
- кроссплатформенность - напиши единожды, запускай где угодно
- безопасность - виртуальная машина обеспечивает контроль доступа
- управление памятью - автоматическая сборка мусора
- динамическая оптимизация - just-in-time-компиляция на лету

**_недостатки:_**
- накладные расходы на виртуальную машину
- зависимость от установленной среды выполнения
- меньшая производительность в некоторых сценариях

**_примеры:_** Java, C#, Python (байткод)

<br/>

### Сравнительная таблица:
|**Система**|**Выходной код**|**Виртуальная машина**|**Компиляция**|**Память**|
|:-|:-|:-|:-|:-|
|**CPython**|Байт-код|Python VM|Интерпретация|Подсчёт ссылок + Сборщик мусора|
|**Java**|Байт-код JVM|JVM|Just-In-Time|Управляемая|
|**Clang**|Машинный код|--|Ahead-Of-Time|Ручная|
|**SQLite**|VDBE байт-код|VDBE|Интерпретация|B-Tree|
